第4周的要求也单一明了
就是要用select 函数改造server
让它可以在单线程的情况下,可以检测到多个客户端并及时给予应对

首先就是对select 函数的解析,网上有很多资料

般一些过来的：

Select的函数格式:
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);

先说明两个结构体：
第一,struct fd_set可以理解为一个集合,这个集合中存放的是文件描述符(filedescriptor),即文件句柄,
这可以是我们所说的普通意义的文件,当然Unix下任何设备、管道、FIFO等都是文件形式,全部包括在内,
所以毫无疑问一个socket就是一个文件,socket句柄就是一个文件描述符。
fd_set集合可以通过一些宏由人为来操作,比如
清空集合 FD_ZERO(fd_set *),
将一个给定的文件描述符加入集合之中 FD_SET(int ,fd_set*),
将一个给定的文件描述符从集合中删除FD_CLR(int,fd_set*),
检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )。
第二,struct timeval是一个大家常用的结构,用来代表时间值,有两个成员,一个是秒数,另一个是毫秒数。

具体解释select的参数:
int maxfdp是一个整数值,是指集合中所有文件描述符的范围,即所有文件描述符的最大值加1,不能错!在Windows中这个参数的值无所谓,可以设置不正确。
fd_set * readfds是指向fd_set结构的指针,这个集合中应该包括文件描述符,
我们是要监视这些文件描述符的读变化的,即我们关心是否可以从这些文件中读取数据了,
如果这个集合中有一个文件可读,select就会返回一个大于0的值,表示有文件可读,
如果没有可读的文件,则根据timeout参数再判断是否超时,若超出timeout的时间,select返回0,若发生错误返回负值。
可以传入NULL值,表示不关心任何文件的读变化。

fd_set * writefds是指向fd_set结构的指针,这个集合中应该包括文件描述符,我们是要监视这些文件描述符的写变化的,
即我们关心是否可以向这些文件中写入数据了,如果这个集合中有一个文件可写,select就会返回一个大于0的值,
表示有文件可写,如果没有可写的文件,则根据timeout参数再判断是否超时,若超出timeout的时间,select返回0,若发生错误返回负值。
可以传入NULL值,表示不关心任何文件的写变化。

fd_set * errorfds同上面两个参数的意图,用来监视文件错误异常。

struct timeval * timeout是select的超时时间,这个参数至关重要,它可以使select处于三种状态,
第一,若将NULL以形参传入,即不传入时间结构,就是将select置于阻塞状态,一定等到监视文件描述符集合中某个文件描述符发生变化为止；
第二,若将时间值设为0秒0毫秒,就变成一个纯粹的非阻塞函数,不管文件描述符是否有变化,都立刻返回继续执行,文件无变化返回0,有变化返回一个正值；
第三,timeout的值大于0,这就是等待的超时时间,即select在timeout时间内阻塞,超时时间之内有事件到来就返回了,否则在超时后不管怎样一定返回,返回值同上述。


返回值：返回状态发生变化的描述符总数。
负值:select错误
正值：某些文件可读写或出错
0:等待超时,没有可读写或错误的文件

select函数具体到咱们在本socket中的应该就是
maxfds 已经给定要求是1024
readfds 是我们要监测的socket集
writefds 和 errorfds 我们也不关心,直接传入0
时间的话等到有变化为主,所以也是传入0即可

定义两组 fd_set readfds 和 testfds , testfds 是当前轮次正在监测的集合,readfds是每时每刻都在变的
刚开始将服务端的socekt 传入 readfds,让开始没伦茨的监测也就是select
当发现有请求变得动的时候,就从0,1023遍历每一个fd,如果在我们正在检测的集合中,有两种情况:
一种是服务端socket,说明有新的客户端请求连接了,就把这个客户端的的fd加入到readfds中,下一轮开始就监测它
另一种是客户端的socket,说明有数据传过来了,我们就接受数据,并处理返回,这部分在前三周均已实现
    而如果接收到的数据为0或者接受异常,就关闭这个连接,并将这个socket客户端从readfds中清除


